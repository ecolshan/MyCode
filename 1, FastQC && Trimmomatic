【本文是来自于华大-黄树嘉的学习资料】

FastQC的安装非常简单,在终端通过命令行下载：
$ wget wget https://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.5.zip ./

解压之后，修改文件夹中fastqc的权限，就可以直接运行了：
$ unzip fastqc_v0.11.5.zip
$ cd FastQC
$ chmod 755 fastqc

FastQC的运行非常简单，直接在终端通过命令行是最有效直接的，下面我给出一个例子：
$ /path_to_fastqc/FastQC/fastqc untreated.fq -o fastqc_out_dir/
命令比较简单，这里唯一值得注意的地方就是 -o 参数用于指定FastQC报告的输出目录，这个目录需要事先创建好，如果不指定特定的目录，那么FastQC的结果会默认输出到测序文件untreated.fq的同一个目录下。
它输出结果只有两个，一个html和一个.zip压缩包。
我们可以直接通过浏览器打开html，就可以看到FastQC给出的所有结果，zip压缩包解压后，从中我们也可以在对应的目录下找到所有的QC图表和Summary数据。


除了上述用法之外，FastQC支持同时输入多个fq文件（或者以通配符的形式输入fq），当我们的fq文件比较多时，这种用法会比较方便，如：
$ /path_to_fastqc/FastQC/fastqc /path_to_fq/*.fq -o fastqc_out_dir/



【切除测序接头序列和read的低质量序列】
Trimmomatic的好处在于，它不但可以用来切除illumina测序平台的接头序列，还可以去除由我们自己指定的特定接头序列，而且同时也能够过滤read末尾的低质量序列，sickle和seqtk只能去除低质量碱基。
具体的原理就是通过滑动一定长度的窗口，计算窗口内的碱基平均质量，如果过低，就直接往后全部切除，
注！意！不是挖掉read中的这部分低质量序列，而是像切菜一样，直接从低质量区域开始把这条read后面的所有其它碱基全！部！剁！掉！否则就是在人为改变实际的基因组序列情况。

现在我们说回如何用Trimmomatic构造序列过滤流程。
首先是安装Trimmomatic。我们可以到它的官网（http://www.usadellab.org/cms/?page=trimmomatic）上获取最新的版本，下载打包好的binary即可，如果打算看它具体的代码，可以在github上找到。
下载后，直接解压，目录下的trimmomatic-*.jar（我下载的是0.36版本）就是执行程序，可以直接使用java来运行。
$ java -jar trimmomatic-0.36.jar

同个目录下还有一个名为adapters的文件夹，这个文件夹中的内容对于我们去除接头序列来说非常重要。其中默认存放的是illumina测序平台的接头序列（fasta格式），在实际的使用过程中，如果需要去除接头，我们需要明确指定对应的序列作为输入参数。
那么这些接头序列具体该如何选择呢？一般来说，目前的HiSeq系列和MiSeq系列用的都是TruSeq3，TruSeq2是以前GA2系列的测序仪所用的，已经很少见了。这些信息都可以在illumina的官网上找到，至于具体该用PE（Pair End）还是SE（Single End）就按照具体的测序类型进行选择就ok了。
如果用的不是illumina测序平台，那么我们也可以按照adapters文件夹下的这些文件的格式做一个新的接头序列，然后再作为参数传入。不过在自定义接头序列的时候，命名时有一些小的细节需要注意，可以参考Trimmomatic的主页文档（The Adapter Fasta），这里就不展开了。
Trimmomatic有两种运行模式：PE和SE。顾名思义，PE就是对应PE测序的，SE则是对应SE测序的。
$ java -jar trimmomatic-0.36.jar
Usage:
       PE [-version] [-threads <threads>] [-phred33|-phred64] [-trimlog <trimLogFile>] [-quiet] [-validatePairs] [-basein <inputBase> | <inputFile1> <inputFile2>] [-baseout <outputBase> | <outputFile1P> <outputFile1U> <outputFile2P> <outputFile2U>] <trimmer1>...
   or:
       SE [-version] [-threads <threads>] [-phred33|-phred64] [-trimlog <trimLogFile>] [-quiet] <inputFile> <outputFile> <trimmer1>...
   or:
       -version
       
下面我分别给出例子来进行说明：
PE模式，HiSeq PE测序：
$ java -jar /path/Trimmomatic/trimmomatic-0.36.jar PE -phred33 -trimlog logfile reads_1.fq.gz reads_2.fq.gz out.read_1.fq.gz out.trim.read_1.fq.gz out.read_2.fq.gz out.trim.read_2.fq.gz ILLUMINACLIP:/path/Trimmomatic/adapters/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:5:20 LEADING:5 TRAILING:5 MINLEN:50

SE模式，HiSeq SE测序：
$ java -jar /path/Trimmomatic/trimmomatic-0.36.jar SE -phred33 -trimlog se.logfile raw_data/untreated.fq out.untreated.fq.gz ILLUMINACLIP:/path/Trimmomatic/adapters/TruSeq3-SE.fa:2:30:10 SLIDINGWINDOW:5:20 LEADING:5 TRAILING:5 MINLEN:50

另外，【可以加入多线程】

同时需要明确指明质量值体系是Phred33还是Phred64，默认是Phred64，这需要特别注意，因为我们现在的测序数据基本都是Phred33的了。
剩下的就是输入的fq和输出的fq，可以用-basein和-baseout指定，也可以不用（如上例子），以及被过滤掉的fq要输出到文件。细心的读者可能已经发现这里PE和SE有一个区别：
在SE模式中，是不需要指定文件来存放被过滤掉的read信息的，后面直接就接Trimmer信息！这是需要注意到的一个地方。

关于后面的Trimmer信息，规定了很多切除接头序列和低质量序列的细节，具体如下：

ILLUMINACLIP，接头序列切除参数。LLUMINACLIP:TruSeq3-PE.fa:2:30:10（省掉了路径）意思分别是：TruSeq3-PE.fa是接头序列，2是比对时接头序列时所允许的最大错误数；30指的是要求PE的两条read同时和PE的adapter序列比对，匹配度加起来超30%，那么就认为这对PE的read含有adapter，并在对应的位置需要进行切除【注】。
10和前面的30不同，它指的是，我就什么也不管，反正只要这条read的某部分和adpater序列有超过10%的匹配率，那么就代表含有adapter了，需要进行去除；

【注】测序的时候往往只会在测到一些部分的adapter，因此read和adaper的时候肯定是不需要要求百分百匹配率的，上述30%和10%其实是比较推荐的值。

SLIDINGWINDOW，滑动窗口长度的参数，SLIDINGWINDOW:5:20代表窗口长度为5，窗口中的平均质量值至少为20，否则会开始切除；

LEADING，规定read开头的碱基是否要被切除的质量阈值；

TRAILING，规定read末尾的碱基是否要被切除的质量阈值；

MINLEN，规定read被切除后至少需要保留的长度，如果低于该长度，会被丢掉。


我的Trimmomatic命令：
[wuq@localhost-3 ~/shan/reference/mydata]$ java -jar /home/wuq/bin/Trimmomatic-0.36/trimmomatic-0.36.jar PE -phred33 -trimlog logfile_L6 KPGP-00001_L6_R1.fq.gz KPGP-00001_L6_R2.fq.gz ./cleandata/KPGP-00001_L6_R1_clean.fq.gz ./cleandata/KPGP-00001_L6_R1_trim.fq.gz ./cleandata/KPGP-00001_L6_R2_clean.fq.gz ./cleandata/KPGP-00001_L6_R2_trim.fq.gz ILLUMINACLIP:/home/wuq/bin/Trimmomatic-0.36/adapters/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:5:20 LEADING:5 TRAILING:5 MINLEN:50
